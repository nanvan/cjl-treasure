查看redis进程(可以用来kill)
	cat /var/run/redis_6379.pid 

hash slot(哈希槽,像停车位)
	16384
	set key时集群通过CRC16校验用哈希槽存储key
	HASH_SLOT = CRC16(key) mod 16384
	
pom.xml文件可以像class文件一样继承(spring-boot-starter <>parent)

设计模式:方法模板(可以在方法里写东西) 和 AOP(只是在方法外写东西) 

我们用redis(key-value数据库)做分布式缓存(将数据放在内存中,这样查询速度远超于硬盘)

电商提升查询的性能:做缓存的时候用String存数据,商品数据可以用json或hash,用hash查key查找单个属性更快

redis可以解决性能问题(将数据存在内存),减少[刷盘]

ES里有做排序,ES是倒排索引(可以根据各个属性查询id即反向查找到该数据,score匹配度)
redis里用hashmap存数据,没有排序

======================================================================================================

[缓存预热],当第一次请求时缓存里没有数据[缓存击穿],用脚本主动去数据库将数据load到内存

同步(A要等B返回结果了才能继续执行),异步(A不用等B直接就进行下一步)

[网站优化]:
	1.并发(提高吞吐量)
	2.异步(mq可以做异步,解耦)
	3.缓存

[缓存失效策略]

Redis[持久化]方式:
	1.RDB(snapshot)快照方式(dump.rdb),当redis挂了,达到数据恢复效果
	2.AOF(Append-only-file)文件追加
	3.Redis-4.0开始支持混合使用(并不是同时开启,而是一种方式,即在缓存预热时用RDB,之后的操作用AOF)

redis里用list(这里的list相当于java里的linkedlist)链表做异步队列
时间复杂度O(1)即不变,O(n)即n越多时间越久

单链表 [1]->[2]->[3]
双链表 [1]<->[2]<->[3]

redis是单线程,那为什么还支持10W的高并发?
	[内存]级别的运算,远超刷盘,
	单线程是因为,cpu的[上下文切换]时间会大于单次计算时间

Redis的[IO多路复用](nginx也用的这个):
	事件模型:单个询问select(服务员去问每个用户),epoll(让用户自己说要什么菜)

*并发(concurrent):
         一个cpu(cpu切换最小单位:线程)
	多线程运行:
		[上下文切换造成性能损耗:线程执行状态的保存,恢复]
*并行(parallel):
	让不同的线程在不同的cpu上跑
	真实的同时提高了性能与吞吐量

*吞吐量(throughout):单位时间内的请求处理量
	单核 时 吞吐量 和 性能 成反比

[缓存淘汰策略]:LRU(Least Recently Used)最近最少使用

操作系统分配内存不是按字节,而是按页为单位进行管理,几KB左右
